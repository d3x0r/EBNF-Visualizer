/*-------------------------------------------------------------------------
EBNF Visualizer
Copyright (c) 2005 Stefan Schoergenhumer, Markus Dopler
supported by Hanspeter Moessenboeck, University of Linz

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.



This class has been generated by the Compiler Generator Coco/R.
See: http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/
-------------------------------------------------------------------------*/

import {Scanner,Token} from "./Scanner.js";
import {Symbol} from "./Graph.js";
import {Graph,Node} from "./Graph.js";
import { EbnfForm } from "./EbnfForm.js";

export class Parser {
	static _EOF = 0;
	static _ident = 1;
	static _terminal = 2;
	static _wrap = 3;
	static maxT = 13;

	static minErrDist = 2;

	static  t;    // last recognized token
	static  la;   // lookahead token
	static  errDist = Parser.minErrDist;



	static  SynErr ( n) {
		if (Parser.errDist >= Parser.minErrDist) Errors.SynErr(Parser.la.line, Parser.la.col, n);
		Parser.errDist = 0;
	}

	static SemErr ( msg) {
		if (Parser.errDist >= Parser.minErrDist) Errors.Error(Parser.t.line, Parser.t.col, msg);
		Parser.errDist = 0;
	}
	
	static Get () {
		for (;;) {
			Parser.t = Parser.la;
			Parser.la = Scanner.Scan();
			if (Parser.la.kind <= Parser.maxT) { ++Parser.errDist; break; }

			Parser.la = Parser.t;
		}
	}
	
	static Expect ( n) {
		if (Parser.la.kind==n) Parser.Get(); else { Parser.SynErr(n); }
	}
	
	static  StartOf ( s) {
		return Parser.set[s][Parser.la.kind];
	}
	
	static  ExpectWeak ( n, follow) {
		if (la.kind == n) Parser.Get();
		else {
			Parser.SynErr(n);
			while (!StartOf(follow)) Parser.Get();
		}
	}
	
	static WeakSeparator (n, syFol, repFol) {
		const s = [];//new bool[maxT+1];
		if (Parser.la.kind == n) { Parser.Get(); return true; }
		else if (Parser.StartOf(repFol)) return false;
		else {
			for (let i=0; i <= Parser.maxT; i++) {
				s.push( Parser.set[syFol][ i] || Parser.set[repFol][ i] || Parser.set[0][i] );
			}
			Parser.SynErr(n);
			while (!s[Parser.la.kind]) Parser.Get();
			return Parser.StartOf(syFol);
		}
	}
	
	static  EBNF() {
		Parser.Rule();
		while (Parser.la.kind == 1) {
			Parser.Rule();
		}
	}

	static Rule() {
		Parser.Expect(1);
		let n;
		let s=Symbol.Find(Parser.t.val);	//look if already known
		
		if(Parser.s==null) n=new Node(new Symbol(Node.nt,Parser.t.val));
		else {
			if(s.typ==Node.nt) {
				let message="ERROR: Nonterminal symbol "+t.val+" has been defined multiple times.";
				EbnfForm.WriteLine(message);
				n=new Node(new Symbol(0,"BUG"));
			} else { //if only considered as terminal symbol until now
				Parser.s.typ=Node.nt;
				Symbol.terminalToNt(s.name);
				Symbol.terminalToNt(s.name);
				Node.terminalToNt(s.name);
				n=Node.Find(s.name);	
			}
		}
					 
		Parser.Expect(4);
		n.sym.graph = Parser.Expr();
		Parser.Expect(5);
		Graph.Finish(n.sym.graph); 
	}

	static Expr() {
		let g
		let g1; 
		g = Parser.Alt();
		let first = true; 	
		while (Parser.la.kind == 6) {
			Parser.Get();
			g1 = Parser.Alt(g1);
			if (first) { Graph.MakeFirstAlt(g); first = false; }
			Graph.MakeAlternative(g, g1); 
			 
		}
		return g;
	}

	static  Alt() {
		let g;
		let g1; 
		g=new Graph();  
		while (Parser.StartOf(1)) {
			g1 = Parser.Sym();
			Graph.MakeSequence(g, g1); 	
		}
		if(g.l==null && g.r==null)
		g=new Graph(new Node(Node.eps,null));
		return g;
	}

	static Sym() {
		let g1;
		let g=new Graph();	 
		switch (Parser.la.kind) {
		case 1: {
			Parser.Get();
			const s=Symbol.Find(Parser.t.val);
			let n;
			if(s!=null)	n= new Node(s);
			else n=new Node(new Symbol(Node.t,Parser.t.val)); //type could be nt, but not known yet
			g=new Graph(n);				
			break;
		}
		case 2: {
			Parser.Get();
			let trim=[Parser.t.val[0]];
			//const temp=Parser.t.val.Trim(trim);
			let start = 0;
			let end = Parser.t.val.length-1;
			while( Parser.t.val[start] == trim ) start++;
			while( Parser.t.val[end] == trim ) end--;
			const temp = Parser.t.val.substring( start, end+1 );
			
			const n =new Node(new Symbol(Node.t,temp));
			g=new Graph(n);				
			
			break;
		}
		case 3: {
			Parser.Get();
			const n =new Node(Node.wrap,null);
			g=new Graph(n);
			
			break;
		}
		case 7: {
			Parser.Get();
			g1 = Parser.Expr();
			Parser.Expect(8);
			g=g1;  
			break;
		}
		case 9: {
			Parser.Get();
			g1 = Parser.Expr();
			Parser.Expect(10);
			Graph.MakeOption(g1);
			g=g1;
			
			break;
		}
		case 11: {
			Parser.Get();
			g1 = Parser.Expr();
			Parser.Expect(12);
			Graph.MakeIteration(g1);
			g=g1;
			
			break;
		}
		default: Parser.SynErr(14); break;
		}
		return g;
	}



	static Parse() {
		Parser.la = new Token();
		Parser.la.val = "";		
		Parser.Get();
		Parser.EBNF();

		Parser.Expect(0);
	}

	static  set = [
		[true,false,false,false, false,false,false,false, false,false,false,false, false,false,false],
		[false,true,true,true, false,false,false,true, false,true,false,true, false,false,false]
	];
} // end Parser


export class Errors {
	 static  count = 0;                                    // number of errors detected
   static  errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
	
	 static  SynErr ( line, col, n) {
		let s;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "terminal expected"; break;
			case 3: s = "wrap expected"; break;
			case 4: s = "\"=\" expected"; break;
			case 5: s = "\".\" expected"; break;
			case 6: s = "\"|\" expected"; break;
			case 7: s = "\"(\" expected"; break;
			case 8: s = "\")\" expected"; break;
			case 9: s = "\"[\" expected"; break;
			case 10: s = "\"]\" expected"; break;
			case 11: s = "\"{\" expected"; break;
			case 12: s = "\"}\" expected"; break;
			case 13: s = "??? expected"; break;
			case 14: s = "invalid Sym"; break;

			default: s = "error " + n; break;
		}
		console.log(Errors.errMsgFormat, line, col, s);
		EbnfForm.WriteLine("ERROR: Line: "+line+" Col: "+ col+": "+ s);
		Errors.count++;
	}

	static  SemErr ( line, col, n) {
		console.log(Errors.errMsgFormat, line, col, ("error " + n));
		Errors.count++;
	}

	 static  Error ( line,  col, s) {
		console.log(Errors.errMsgFormat, line, col, s);
		Errors.count++;
	}

	 static  Exception ( s) {
		console.error(s); 
		process.exit(0);
	}
} // Errors

