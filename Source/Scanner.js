/*-------------------------------------------------------------------------
EBNF Visualizer
Copyright (c) 2005 Stefan Schoergenhumer, Markus Dopler
supported by Hanspeter Moessenboeck, University of Linz

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


This class has been generated by the Compiler Generator Coco/R.
See: http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/
-------------------------------------------------------------------------*/




export class Token {
	 kind = 0;    // token kind
	  pos = 0;     // token position in the source text (starting at 0)
	  col = 0;     // token column (starting at 0)
	  line = 0;    // token line (starting at 1)
	  val= "";  // token value
	  next= {};  /** Token */ // AW 2003-03-07 Tokens are kept in linked list
}

export class Buffer {
	static EOF = "\u{100}";
	static buf = null;
	static bufLen = 0;
	static pos = 0;
	
	/* stream */
	static  Fill ( s) {
		Buffer.bufLen =  s.length;
		Buffer.buf = [...s];
		Buffer.pos = 0;
	}
	
	
	static Read () {
		if (Buffer.pos < Buffer.bufLen) return Buffer.buf[Buffer.pos++];
		else return Buffer.EOF;                          /* pdt */
	}

	static Peek () {
		if (Buffer.pos < Buffer.bufLen) return Buffer.buf[Buffer.pos];
		else return Buffer.EOF;                          /* pdt */
	}
	
	/* AW 2003-03-10 moved this from ParserGen.cs */
	static  GetString (beg, end) {
		let s= "";
		let oldPos = Buffer.Pos;
		Buffer.Pos = beg;
		while (beg < end) { s += Buffer.Read(); beg++; }
		Buffer.Pos = oldPos;
		return s;
	}

	static get Pos() { return pos; }
	static set Pos(value){
			if (value < 0) pos = 0; 
			else if (value >= bufLen) pos = bufLen; 
			else pos = value;
		}
}

export class Scanner {
	static EOL = '\n';
	  static eofSym = 0; /* pdt */
	  static charSetSize = 256;
	  static maxT = 13;
	  static  noSym = 13;
	static start = [
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  2,  0,  0,  0,  0,  3, 10, 11,  0,  0,  0,  0,  8,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  0,  0,
	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 12,  5, 13,  0,  1,
	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 14,  9, 15,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  -1];


	static t= null;          // current token
	static  ch='';          // current input character
	static  pos=0;          // column number of current character
	static  line=0;         // line number of current character
	static  lineStart=0;    // start position of current line
	static oldEols=0;      // EOLs that appeared in a comment;
	static  ignore = [];  // set of characters to be ignored by the scanner

	static  tokens = null;     // the complete input token stream
	static  pt = null;         // current peek token
	
	static Init ( s) {
		Buffer.Fill(s);
		Scanner.pos = -1; Scanner.line = 1; Scanner.lineStart = 0;
		Scanner.oldEols = 0;
		Scanner.NextCh();
		//Scanner.ignore = new BitArray(charSetSize+1);
		Scanner.ignore[32] = true;  // blanks are always white space
		Scanner.ignore[9] = true; Scanner.ignore[10] = true; Scanner.ignore[13] = true; 
		//--- AW: fill token list
		Scanner.tokens = new Token();  // first token is a dummy
		let node = Scanner.tokens;
		do {
			node.next = Scanner.NextToken();
			node = node.next;
		} while (node.kind != Scanner.eofSym);
		node.next = node;
		node.val = "EOF";
		Scanner.t = Scanner.pt = Scanner.tokens;
	}
	
	static NextCh() {
		if (Scanner.oldEols > 0) { Scanner.ch = Scanner.EOL; Scanner.oldEols--; } 
		else {
			Scanner.ch = Buffer.Read(); Scanner.pos++;
			// replace isolated '\r' by '\n' in order to make
			// eol handling uniform across Windows, Unix and Mac
			if (Scanner.ch == '\r' && Buffer.Peek() != '\n') Scanner.ch = Scanner.EOL;
			if (Scanner.ch == Scanner.EOL) { Scanner.line++; Scanner.lineStart = Scanner.pos + 1; }
		}

	}



	static CheckLiteral() {
		switch (Scanner.t.val) {
			default: break;
		}
	}

	/* AW Scan() renamed to NextToken() */
	static NextToken() {
		while (Scanner.ignore[Scanner.ch.codePointAt(0)]) Scanner.NextCh();

		const t = new Token();
		Scanner.t = t;
		t.pos = Scanner.pos; t.col = Scanner.pos - Scanner.lineStart + 1; t.line = Scanner.line; 
		let state = Scanner.start[Scanner.ch.codePointAt(0)];
		let buf = '';
		buf+= Scanner.ch; Scanner.NextCh();
		while( state != -2) {
			const st = state;
			state = -2;
			switch (st) {
				case -1: { t.kind = Scanner.eofSym; break; } // NextCh already done /* pdt */
				case 0: { t.kind = Scanner.noSym; break; }   // NextCh already done
				case 1:
					if ((Scanner.ch >= '0' && Scanner.ch <= '9' || Scanner.ch >= 'A' && Scanner.ch <= 'Z' || Scanner.ch == '_' || Scanner.ch >= 'a' && Scanner.ch <= 'z')) {buf+=(Scanner.ch); Scanner.NextCh(); state=1;break;}
					else {t.kind = 1; break;}
				case 2:
					if ((Scanner.ch >= ' ' && Scanner.ch <= '!' || Scanner.ch >= '#' && Scanner.ch <= '~')) {buf+=(Scanner.ch); Scanner.NextCh(); state=2;break;}
					else if (Scanner.ch == '"') {buf+=(Scanner.ch); Scanner.NextCh(); state=4;break;}
					else {t.kind = Scanner.noSym; break;}
				case 3:
					if ((Scanner.ch >= ' ' && Scanner.ch <= '&' || Scanner.ch >= '(' && Scanner.ch <= '~')) {buf+=(Scanner.ch); Scanner.NextCh(); state=3;break;}
					else if (Scanner.ch == 39) {buf+=(Scanner.ch); Scanner.NextCh(); state=4;break;}
					else {t.kind = Scanner.noSym; break;}
				case 4:
					{t.kind = 2; break;}
				case 5:
					if (Scanner.ch == 'n') {buf+=(Scanner.ch); Scanner.NextCh(); state=6;break;}
					else {t.kind = Scanner.noSym; break;}
				case 6:
					{t.kind = 3; break;}
				case 7:
					{t.kind = 4; break;}
				case 8:
					{t.kind = 5; break;}
				case 9:
					{t.kind = 6; break;}
				case 10:
					{t.kind = 7; break;}
				case 11:
					{t.kind = 8; break;}
				case 12:
					{t.kind = 9; break;}
				case 13:
					{t.kind = 10; break;}
				case 14:
					{t.kind = 11; break;}
				case 15:
					{t.kind = 12; break;}
			}
			done: 
			if( state < 0 )
				t.val = buf;
		}
		return Scanner.t;
	}
	
	/* AW 2003-03-07 get the next token, move on and synch peek token with current */
	 static  Scan () {
		Scanner.t = Scanner.pt = Scanner.t.next;
		return Scanner.t;
	}

	/* AW 2003-03-07 get the next token, ignore pragmas */
	 static  Peek () {
		do {                      // skip pragmas while peeking
			Scanner.pt = Scanner.pt.next;
		} while (Scanner.pt.kind > Scanner.maxT);
		return Scanner.pt;
	}
	
	/* AW 2003-03-11 to make sure peek start at current scan position */
	static ResetPeek () { Scanner.pt = Scanner.t; }

} // end Scanner

